//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.34014
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Common;
	
namespace Learning
{
		public class StateManager
		{
			List<State> stList = null;
			Cell[][][] original;
			int endX, endY, gridSize, sight;
			
					
		public StateManager ( Cell[][][] _original, int _endX, int _endY, int _gridSize, int _sight )
				{
					stList = new List<State>();
					original = _original;
					endX = _endX;
					endY = _endY;
					gridSize = _gridSize;
					sight = _sight;
					
				}
				
				public State getState( double[] _inputs ){
					int i;
					foreach( State s in stList ){
						i = 0;
						for( ; i < s.sensors.Length; i ++ ){
							if( s.sensors[i] != _inputs[i] )
								break;
						}
						if( i == s.sensors.Length )
							return s;
					}
					return null;
				}
				
				public State getState( int id ){
					if( stList.Count > id )
						return stList[id];
					else
						return null; 
				}
				
				//add an State in the list, and return it, 
				//if it exists in the list, then just return it.
				public State addState(  int time, int currX, int currY  ){
					double[] sensor4Block = new double[ sight * sight ];
					double[] sensor4Goal = new double[ sensor4Block.Length ];
					int focusX, focusY;
					for( int j = 0; j < sensor4Block.Length; j++ ){
						focusX = currX-(sight-1)/2+(j%sight);
						focusY = currY-(sight-1)/2+(j/sight);
						
						if( focusX >= 0 && focusX <= gridSize-1 && focusY >= 0 && focusY <= gridSize-1 ){
							if( original[time][focusX][focusY].blocked || original[time][focusX][focusY].seen ){
								sensor4Block[j] = 1; // an obstacle
								sensor4Goal[j] = 0;
							}
							else if ( focusX == endX && focusY == endY ){
								sensor4Goal[j] = 1; // the goal
								sensor4Block[j] = 0;
							}
							else{
								sensor4Block[j] = 0; // can go
								sensor4Goal[j] = 0;
							}
						}
						else{
							sensor4Block[j] = 1; // out of the map
							sensor4Goal[j] = 0;
						}
					} // j
					double[] allSensors = new double[ sensor4Block.Length + sensor4Goal.Length ];
					sensor4Block.CopyTo( allSensors, 0 );
					sensor4Goal.CopyTo( allSensors, sensor4Block.Length );
					
					State newState = getState( allSensors );
					if( newState == null )
						return addState( allSensors );
					else
						return newState;
				}
				
				public State addState( double[] _inputs ){
					State newState = new State( stList.Count, _inputs );
					stList.Add( newState );
					return newState;
				}
				
				public void reset(){
					stList.Clear();
				}
				
//				public void makeADJMatrix( ){
//					adjMatrix = new double[ stList.Count, stList.Count ];
//					
//					for( int i = 0; i < stList.Count; i++ ){
//						List<int> near = getADJStates( i );
//						for( int j = 0; j < near.Count; j++ ){
//							adjMatrix[ i, near[j] ] = 1;
//							adjMatrix[ near[j], i ] = 1;
//						}
//					}
//				}
//				
//				private List<int> getADJStates( int stateNumber ){
//					List<int> near = new List<int>();
//					int x = stList[ stateNumber ].x;
//					int y = stList[ stateNumber ].y;
//					
//					int xm = x-1;
//					int xp = x+1;
//					int ym = y-1;
//					int yp = y+1;
//					
//										
//					int i = 0;
//					foreach( State s in stList ){
//						if( s.x == xm && s.y == y )
//							near.Add( s.id );
//						else if( s.x == xp && s.y == y )
//							near.Add( s.id );
//						else if( s.x == x && s.y == ym )
//							near.Add( s.id );
//						else if( s.x == x && s.y == yp )
//							near.Add( s.id );				
//					}
//					return near;
//				}
		}
}

